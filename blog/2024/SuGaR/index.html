<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> SuGaR | Semyeong Yu </title> <meta name="author" content="Semyeong Yu"> <meta name="description" content="Surface-Aligned Gaussian Splatting for Efficient 3D Mesh Reconstruction and High-Quality Mesh Rendering (CVPR 2024)"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://semyeong-yu.github.io/blog/2024/SuGaR/"> <script src="/assets/js/theme.js?a5ca4084d3b81624bcfa01156dae2b8e"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> <style type="text/css">.fake-img{background:#bbb;border:1px solid rgba(0,0,0,0.1);box-shadow:0 0 4px rgba(0,0,0,0.1);margin-bottom:12px}.fake-img p{font-family:monospace;color:white;text-align:left;margin:12px 0;text-align:center;font-size:16px}</style> </head> <body> <d-front-matter> <script async type="text/json">
      {
            "title": "SuGaR",
            "description": "Surface-Aligned Gaussian Splatting for Efficient 3D Mesh Reconstruction and High-Quality Mesh Rendering (CVPR 2024)",
            "published": "September 05, 2024",
            "authors": [
              
            ],
            "katex": {
              "delimiters": [
                {
                  "left": "$",
                  "right": "$",
                  "display": false
                },
                {
                  "left": "$$",
                  "right": "$$",
                  "display": true
                }
              ]
            }
          }
    </script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Semyeong</span> Yu </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">blog </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>SuGaR</h1> <p>Surface-Aligned Gaussian Splatting for Efficient 3D Mesh Reconstruction and High-Quality Mesh Rendering (CVPR 2024)</p> </d-title> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div> <a href="#abstract">Abstract</a> </div> <div> <a href="#surface-aligned-3dgs">Surface-Aligned 3DGS</a> </div> <ul> <li> <a href="#regularization">Regularization</a> </li> <li> <a href="#approximation-of-density-function">Approximation of Density function</a> </li> </ul> <div> <a href="#mesh-reconstruction">Mesh reconstruction</a> </div> <ul> <li> <a href="#obtain-mesh">Obtain Mesh</a> </li> <li> <a href="#mesh-by-poission-reconstruction">Mesh by Poission Reconstruction</a> </li> </ul> <div> <a href="#refine-mesh">Refine Mesh</a> </div> <ul> <li> <a href="#refine-mesh-by-gaussians">Refine Mesh by Gaussians</a> </li> </ul> <div> <a href="#code-flow">Code Flow</a> </div> <div> <a href="#question">Question</a> </div> </nav> </d-contents> <h2 id="sugar-surface-aligned-gaussian-splatting-for-efficient-3d-mesh-reconstruction-and-high-quality-mesh-rendering">SuGaR: Surface-Aligned Gaussian Splatting for Efficient 3D Mesh Reconstruction and High-Quality Mesh Rendering</h2> <h4 id="antoine-guédon-vincent-lepetit">Antoine Guédon, Vincent Lepetit</h4> <blockquote> <p>paper :<br> <a href="https://arxiv.org/abs/2311.12775" rel="external nofollow noopener" target="_blank">https://arxiv.org/abs/2311.12775</a><br> project website :<br> <a href="https://anttwo.github.io/sugar/" rel="external nofollow noopener" target="_blank">https://anttwo.github.io/sugar/</a><br> code :<br> <a href="https://github.com/Anttwo/SuGaR" rel="external nofollow noopener" target="_blank">https://github.com/Anttwo/SuGaR</a><br> reference :<br> NeRF and 3DGS Study</p> </blockquote> <h2 id="abstract">Abstract</h2> <ul> <li> <p>surface 점 sampling :<br> surface 근처의 점 \(p\) 를<br> <code class="language-plaintext highlighter-rouge">Gaussians의 곱 분포</code>로 sampling</p> </li> <li> <p>regularization term :<br> 3DGS가 surface 잘 나타내도록 (well-distributed) 하기 위해<br> <code class="language-plaintext highlighter-rouge">density</code> function 또는 <code class="language-plaintext highlighter-rouge">SDF</code>로 <code class="language-plaintext highlighter-rouge">regularization</code> loss term</p> </li> <li> <p>obtain mesh using level set points :<br> 점 \(p\) 주위(\(3 \sigma (v)\))의 points를 sampling하고<br> density 계산하여 oriented <code class="language-plaintext highlighter-rouge">level set points</code> 구한 뒤<br> Poisson equation으로 <code class="language-plaintext highlighter-rouge">mesh</code> 구함</p> </li> <li> <p>mesh refinement :<br> triangle mesh에 new Gaussians binding하여<br> mesh optimize할 때 new Gaussians도 함께 optimize</p> </li> </ul> <h2 id="surface-aligned-3dgs">Surface-Aligned 3DGS</h2> <h3 id="regularization">Regularization</h3> <ul> <li> <p>문제 :<br> 3DGS는 <code class="language-plaintext highlighter-rouge">unstructured</code><br> \(\rightarrow\) <code class="language-plaintext highlighter-rouge">surface</code> 나타내지 않음</p> </li> <li> <p>해결 :<br> <code class="language-plaintext highlighter-rouge">regularization</code> loss term<br> \(\rightarrow\) 3DGS가 well-distributed and aligned with surface (flat)</p> <ul> <li>well-distributed : <ul> <li>Gaussians끼리 <code class="language-plaintext highlighter-rouge">overlap 적음</code> </li> <li>(surface에 가까운) point \(p\) 와 <code class="language-plaintext highlighter-rouge">가장 가까운 Gaussian</code> \(g^{\ast}\) 가 다른 Gaussians보다 \(p\) 의 <code class="language-plaintext highlighter-rouge">density에 훨씬 많이 기여</code><br> \(g^{\ast} = \text{argmin}_{g}(p - \mu_{g})^T \Sigma_{g}^{-1}(p - \mu_{g})\)</li> </ul> </li> </ul> </li> </ul> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-09-05-SuGaR/1-480.webp 480w,/assets/img/2024-09-05-SuGaR/1-800.webp 800w,/assets/img/2024-09-05-SuGaR/1-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/2024-09-05-SuGaR/1.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <ul> <li>surface 근처의 점 sampling : <ul> <li>assumption :<br> 거의 surface 위에 있다고 볼 수 있을 정도로 아주 가까운<br> <code class="language-plaintext highlighter-rouge">surface 근처</code>의 \(p\) 를 <code class="language-plaintext highlighter-rouge">Gaussian들의 곱 분포로 sampling</code><br> \(p \sim \prod_{g} N(\cdot; \mu_{g}, \Sigma{g})\) <ul> <li>‘3DGS가 잘 학습됐다면’ small Gaussians는 surface에 아주 가까운 점들의 확률처럼 생각할 수 있고,<br> 그 small Gaussians의 곱이 나타내는 분포는 surface 근처의 좁은 영역에 집중된 분포를 나타낼 것이고,<br> 이로부터 sampling한 점 \(p\) 는 실제 object surface에 가까울 것이라는 가정</li> <li>이렇게 sampling한 points는 regularization term에 대해 high gradient를 가지는 부분임</li> </ul> </li> </ul> </li> <li> <code class="language-plaintext highlighter-rouge">density function</code> : <ul> <li>\(d(p) = \sum_{g} \alpha_{g} \text{exp}(-\frac{1}{2}(p - \mu_{g})^T \Sigma_{g}^{-1}(p - \mu_{g}))\)<br> where \(\text{exp}(-\frac{1}{2}(p - \mu_{g})^T \Sigma_{g}^{-1}(p - \mu_{g}))\) : posterior<br> (점 \(p\) 에 더 가까운 Gaussian의 \(\alpha_{g}\) 가 \(p\) 의 density에 더 많이 기여)<br> where \((p - \mu_{g})^T \Sigma_{g}^{-1}(p - \mu_{g})\) : <code class="language-plaintext highlighter-rouge">Mahalanobis distance</code><br> (\(p\) 가 Gaussian distribution 평균 \(\mu_{g}\) 에서 “상대적으로” 얼마나 떨어져 있는지)<br> (\(p\) 가 평균으로부터 같은 거리만큼 떨어져있더라도 convariance가 작은 방향에 있을수록 Mahalanobis distance가 커짐)</li> <li>approx. ideal density function \(\bar d(p) \in [0, 1]\) : <ul> <li>가정 1) well-distributed Gaussians by regularization term 이므로<br> overlap 없다는 전제 하에 <code class="language-plaintext highlighter-rouge">하나</code>의 Gaussian \(g^{\ast}\) 가 point \(p\) 의 density 결정</li> <li>가정 2) Gaussians가 진짜 surface를 묘사하려면 <code class="language-plaintext highlighter-rouge">semi-transparent하지 않아야</code> 좋음<br> \(\rightarrow\) \(a_{g} = 1\) for any Gaussians</li> <li>위의 가정과 아래 수식 유도(<strong>Approximation of Density function</strong>) 에 따르면<br> \((p - \mu_{g})^T \Sigma_{g}^{-1}(p - \mu_{g}) \approx \frac{1}{s_{g}^2} \langle p-\mu_{g}, n_g \rangle^{2}\) 이고<br> 근사해서 구한 ideal density function은<br> \(\bar d(p) = \text{exp}(-\frac{1}{2s_{g^{\ast}}^2} \langle p-\mu_{g^{\ast}}, n_{g^{\ast}} \rangle^{2})\)<br> where \(g^{\ast} = \text{argmin}_{g}(p - \mu_{g})^T \Sigma_{g}^{-1}(p - \mu_{g})\)</li> </ul> </li> </ul> </li> </ul> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-09-05-SuGaR/2-480.webp 480w,/assets/img/2024-09-05-SuGaR/2-800.webp 800w,/assets/img/2024-09-05-SuGaR/2-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/2024-09-05-SuGaR/2.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-09-05-SuGaR/3-480.webp 480w,/assets/img/2024-09-05-SuGaR/3-800.webp 800w,/assets/img/2024-09-05-SuGaR/3-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/2024-09-05-SuGaR/3.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <ul> <li> <code class="language-plaintext highlighter-rouge">Regularization on density</code> : <ul> <li> \[R = | d(p) - \bar d(p) |\] <ul> <li>\(d\) : <code class="language-plaintext highlighter-rouge">density</code> function</li> <li>\(\bar d\) : approx. <code class="language-plaintext highlighter-rouge">ideal density</code> function<br> where 하나의 불투명한 Gaussian이 point density 결정</li> </ul> </li> <li>근데 density function \(d\) 로 regularize하면 아래의 문제가 있다 <ul> <li>\(d\) 는 exponential term으로 이루어져 있으므로 scale이 너무 커서 optimization에 별로다</li> <li>approx. ideal density function을 구할 때 flat Gaussian으로 surface를 나타내는 게 목적이라고 가정하였는데,<br> Gaussian이 완전히 flat 하면 \(s_{g} = 0\) 이 되어 \(\bar d(p) \rightarrow 0\) 이므로<br> 모든 level set (표면)이 \(\mu_{g}\) 를 지나고 normal \(n_{g}\) 를 가지는 2D 상의 plane이 되어<br> level sets 고려하는 게 무의미해진다<br> 따라서 surface를 나타내기 위해 flat하게 Gaussian을 만드는 게 목적이지만<br> 그렇다고 완전히 flat하면 안 됨</li> </ul> </li> </ul> </li> <li> <code class="language-plaintext highlighter-rouge">Regularization on SDF</code> : <ul> <li>density function 말고 <code class="language-plaintext highlighter-rouge">SDF</code> <a href="https://semyeong-yu.github.io/blog/2024/SDF/">Link</a> 로 loss 만들면 optimization 더 잘 됨<br> (Gaussians가 surface에 더 잘 align됨)<br> \(R = \frac{1}{| P |} \sum_{p \in P} | \hat f(p) - f(p) |\) <ul> <li>\(f(p) = \langle p-\mu_{g^{\ast}}, n_{g^{\ast}} \rangle = \pm s_{g^{\ast}} \sqrt{-2log(\bar d(p))}\) :<br> <code class="language-plaintext highlighter-rouge">ideal distance</code> (SDF) b.w. point \(p\) and true surface<br> (\(\bar d(p) = 1\) 이면, 즉 SDF \(f(p) = 0\) (zero level-set)이면, true surface를 나타냄)</li> <li>\(\hat f(p)\) :<br> <code class="language-plaintext highlighter-rouge">estimated distance</code> b.w. point \(p\) and depth at projection of \(p\)<br> (\(f(p)\) 를 직접 계산하는 건 빡세므로 training view-points에 대해 Radix Sort로 Gaussian rasterize할 때 사용한 Gaussian depth 값들을 rendering하여 depth map을 만들어서 estimated \(\hat f(p)\) 구함)</li> </ul> </li> </ul> </li> <li> <code class="language-plaintext highlighter-rouge">Regularization on normal</code> vector : <ul> <li>normal vector의 방향 \(n_{g}\) 을 SDF gradient 방향으로 맞춰주기 위해<br> (normal vector 방향을 잘 잡아줘야 surface에 잘 align됨)<br> \(R_{Norm} = \frac{1}{| P |} \sum_{p \in P} \| \frac{\nabla f(p)}{\| \nabla f(p) \|} - n_{g^{\ast}} \|^2\)</li> </ul> </li> </ul> <h3 id="approximation-of-density-function">Approximation of Density function</h3> <ul> <li> <p>density function이 실제 surface를 잘 나타낸다면<br> \(p\) 에 가장 기여가 큰 Gaussian이 surface에 align되어 flat해야 한다<br> 이 때, <code class="language-plaintext highlighter-rouge">flat Gaussian</code>의 경우 Mahalanobis distance의 주 요인은 <code class="language-plaintext highlighter-rouge">covariance의 가장 짧은 축</code> \(s_{g}\) 이므로<br> 아래와 같이 approx. ideal density function 식을 유도할 수 있다</p> </li> <li> <p>\(\bar d(p) = \text{exp}(-\frac{1}{2s_{g^{\ast}}^2} \langle p-\mu_{g^{\ast}}, n_{g^{\ast}} \rangle^{2})\) 유도 TBD <code class="language-plaintext highlighter-rouge">????</code><br> Eigendecomposition을 하면 \(\Sigma_{g} = Q \Lambda Q^T\)<br> where \(s_g\) : convariance가 가장 작은 방향의 vector<br> where \(n_g = \frac{s_g}{\| s_g \|}\)</p> </li> </ul> <h2 id="mesh-reconstruction">Mesh reconstruction</h2> <h3 id="obtain-mesh">Obtain Mesh</h3> <ul> <li> <p>문제 :<br> <code class="language-plaintext highlighter-rouge">Densification</code>을 거치면 3DGS 수가 너무 <code class="language-plaintext highlighter-rouge">많아</code>지고 너무 <code class="language-plaintext highlighter-rouge">작아</code>져서<br> texture나 detail을 나타내기 힘듦<br> \(\rightarrow\) 거의 모든 곳에서 density function \(d = 0\) 이고,<br> 위에서 언급했듯이 level sets 고려하는 게 의미가 없어져서<br> Marching Cubes 기법으로 이러한 <code class="language-plaintext highlighter-rouge">sparse density function</code>의 <code class="language-plaintext highlighter-rouge">level sets</code>를 추출하기 어렵</p> </li> <li> <p>해결 :</p> <ul> <li>과정 1)<br> Gaussians로 계산한 density function level set 상의 <code class="language-plaintext highlighter-rouge">visible</code> part에 대해 3D <code class="language-plaintext highlighter-rouge">point sampling</code><br> \(n\) 개의 3D points \(\{ p + t_i v_i \}_{i=1}^n\) sampling<br> where \(p\) : depth map에 따른 3D point<br> where \(t_i \in [-3 \sigma_{g}(v), 3\sigma_{g}(v)]\) (visible part)<br> where \(v_i\) : ray direction</li> <li>과정 2)<br> \(d_i = d(p + t_i v_i) = \sum_{g} \alpha_{g} \text{exp}(-\frac{1}{2}((p + t_i v_i) - \mu_{g})^T \Sigma_{g}^{-1}((p + t_i v_i) - \mu_{g}))\) 로<br> <code class="language-plaintext highlighter-rouge">density 계산</code>한 뒤 level parameter \(\lambda\) 에 대해<br> \(d_i \lt \lambda \lt d_j\) 이면,<br> range \([d_i, d_j]\) 안에 <code class="language-plaintext highlighter-rouge">level set point</code> 있다고 판단<br> (아! 그 범위 안에 표면 위의 점이 있구나!)</li> <li>과정 3)<br> 해당 level set points와 normals (oriented 3d point clouds \(\vec V\))를 이용하여<br> <code class="language-plaintext highlighter-rouge">Poisson reconstruction</code>으로 surface <code class="language-plaintext highlighter-rouge">mesh</code> 얻음<br> (아래에서 설명)</li> </ul> </li> </ul> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-09-05-SuGaR/4-480.webp 480w,/assets/img/2024-09-05-SuGaR/4-800.webp 800w,/assets/img/2024-09-05-SuGaR/4-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/2024-09-05-SuGaR/4.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <h3 id="mesh-by-poisson-reconstruction">Mesh by Poisson Reconstruction</h3> <ul> <li> <p>Poisson surface reconstruction :<br> <code class="language-plaintext highlighter-rouge">3D Point Clouds</code>를 <code class="language-plaintext highlighter-rouge">3D Mesh</code>로 변환하는 고전적인 방법 (출처 : <a href="https://xoft.tistory.com/72" rel="external nofollow noopener" target="_blank">Link</a>)</p> </li> <li> <p>Let indicator function \(\chi_{M}(p) = \begin{cases} 1 &amp; \text{if} &amp; p \in M \\ 0 &amp; \text{if} &amp; p \notin M \end{cases}\)<br> where \(M\) : object mesh 내부</p> </li> </ul> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-09-05-SuGaR/5-480.webp 480w,/assets/img/2024-09-05-SuGaR/5-800.webp 800w,/assets/img/2024-09-05-SuGaR/5-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/2024-09-05-SuGaR/5.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <ul> <li>주어진 <code class="language-plaintext highlighter-rouge">oriented 3d point clouds</code> \(\vec V\) 를 approx.하는 <code class="language-plaintext highlighter-rouge">indicator gradient</code> \(\nabla \chi\) 를 찾아야 한다<br> 이를 풀기 위해 Possion Equation을 사용하자 <ul> <li> <code class="language-plaintext highlighter-rouge">Possion Equation</code> :<br> \(\nabla^{2} \phi = f\)<br> where \(\nabla = (\frac{\partial}{\partial x}, \frac{\partial}{\partial y}, \frac{\partial}{\partial z})\)<br> \(\rightarrow\)<br> \((\frac{\partial^{2}}{\partial x^2}+\frac{\partial^{2}}{\partial y^2}+\frac{\partial^{2}}{\partial z^2}) \phi (x, y, z) = f(x, y, z)\)<br> 여기서 scalar field \(f\) 가 주어지면,<br> scalar field \(\phi\) 를 찾을 수 있다</li> <li>\(\nabla \chi \approx \vec V\) 원하는 상황인데<br> 양변에 divergence를 취하면<br> \(\nabla \cdot \nabla \chi = \nabla \cdot \vec V\) 은 Poisson Equation 꼴이므로<br> \(\nabla \cdot \vec V\) 를 알면 \(\chi\) 를 알 수 있다</li> </ul> </li> </ul> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-09-05-SuGaR/6-480.webp 480w,/assets/img/2024-09-05-SuGaR/6-800.webp 800w,/assets/img/2024-09-05-SuGaR/6-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/2024-09-05-SuGaR/6.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <ul> <li>Implementation : <ul> <li>oriented 3d point clouds가 주어지면<br> 모든 points를 포함하는 큰 육면체를 만들고<br> 이를 <code class="language-plaintext highlighter-rouge">Octree</code> (육면체를 8등분하는 tree)를 사용하여 분할 (Fig 1.)</li> <li>input point clouds \(\vec V\) 는 주변 octree들의 합으로 설계하고,<br> octree node의 depth는 Gaussian의 variance로 설계하여<br> input point clouds 근처의 octreee들을 Gaussian으로 표현하면<br> vector field \(\vec V\) (Fig 2.) 를 얻을 수 있다</li> <li>각 차원을 편미분 (Divergence)하면 scalar field \(\nabla \cdot \vec V\) (Fig 3.)를 얻을 수 있고,<br> Poisson equation \(\nabla \cdot \nabla \chi = \nabla \cdot \vec V\) 에 의해<br> indicator function \(\chi\) 도 알 수 있다<br> octree의 깊이 별로 각 node의 \(\nabla \vec V\) 값 (Fig 3.)과 \(\nabla \nabla \chi\) 값 (Fig 4.)의 차이를 최소화함으로써 indicator function \(\chi\) 를 구한다</li> <li>mesh화 : input point clouds를 indicator function \(\chi\) 의 입력으로 넣어서 나온 결과값들을 평균 내고, 이 값과 같은 값을 출력하는 좌표들을 surface로 간주 (Fig 5.)하여 Marching Cube 알고리즘으로 mesh 생성<br> (Octree Node마다 Marching Cube Polygon 생성)<br> (여러 fine Octree Node가 하나의 coarse Octree Node를 공유할 때 생기는 문제를 해결하기 위해 fine Octree Node 면의 부분을 coarse한 면으로 projection하는 방법 사용)</li> <li>octree 깊이가 깊어질수록 시간과 memory를 많이 잡아먹긴 하지만, recon.하는 mesh 수가 더 많아서 mesh fine detail을 살릴 수 있음 (Fig 6.)</li> </ul> </li> </ul> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-09-05-SuGaR/7-480.webp 480w,/assets/img/2024-09-05-SuGaR/7-800.webp 800w,/assets/img/2024-09-05-SuGaR/7-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/2024-09-05-SuGaR/7.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Fig 1. </div> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-09-05-SuGaR/8-480.webp 480w,/assets/img/2024-09-05-SuGaR/8-800.webp 800w,/assets/img/2024-09-05-SuGaR/8-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/2024-09-05-SuGaR/8.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Fig 2. vector field (oriented point clouds) </div> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-09-05-SuGaR/10-480.webp 480w,/assets/img/2024-09-05-SuGaR/10-800.webp 800w,/assets/img/2024-09-05-SuGaR/10-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/2024-09-05-SuGaR/10.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Fig 3. scalar field (divergence of oriented point clouds) </div> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-09-05-SuGaR/9-480.webp 480w,/assets/img/2024-09-05-SuGaR/9-800.webp 800w,/assets/img/2024-09-05-SuGaR/9-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/2024-09-05-SuGaR/9.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Fig 4. scalar field (laplacian of indicator function) </div> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-09-05-SuGaR/11-480.webp 480w,/assets/img/2024-09-05-SuGaR/11-800.webp 800w,/assets/img/2024-09-05-SuGaR/11-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/2024-09-05-SuGaR/11.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Fig 5. surface mesh </div> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-09-05-SuGaR/12-480.webp 480w,/assets/img/2024-09-05-SuGaR/12-800.webp 800w,/assets/img/2024-09-05-SuGaR/12-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/2024-09-05-SuGaR/12.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Fig 6. octree 깊이에 따른 mesh recon. 비교 </div> <h2 id="refine-mesh">Refine Mesh</h2> <h3 id="refine-mesh-by-gaussians">Refine Mesh by Gaussians</h3> <ul> <li> <p>문제 :<br> Poisson reconstruction으로 구한 mesh만 사용하면 rendering quality가 좋지 않음</p> </li> <li> <p>해결 :<br> 새로 sampling한 new Gaussians를 (triangle) mesh에 binding하고,<br> 해당 <code class="language-plaintext highlighter-rouge">Gaussians</code>과 <code class="language-plaintext highlighter-rouge">mesh</code>를 GS rasterizer로 <code class="language-plaintext highlighter-rouge">함께 optimize</code></p> <ul> <li>과정 1)<br> mesh surface 상에서 <code class="language-plaintext highlighter-rouge">triangle</code> 당 \(n\) 개의 <code class="language-plaintext highlighter-rouge">new thin 3D Gaussians를 sampling</code>하여<br> Gaussians를 triangle에 bind</li> <li>과정 2)<br> mesh vertices in barycentric coordinate (무게중심 좌표계) 이용해서<br> 각 Gaussian의 mean을 explicitly 계산할 수 있음<br> (barycentric coordinate : 삼각형 내부의 점을 세 꼭짓점의 가중치로 표현)</li> <li>과정 3)<br> Gaussians를 mesh triangle에 aligned되도록 flat하게 유지하기 위해<br> each Gaussian은 2개의 learnable scaling factor \(s_x, s_y\) 와 1개의 learnable 2D quaternion \(q=a+bi\) 을 가지고 있음<br> (Gaussians optimize하여 mesh optimze될 때 new thin Gaussians도 함께 optimize)</li> </ul> </li> </ul> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-09-05-SuGaR/13-480.webp 480w,/assets/img/2024-09-05-SuGaR/13-800.webp 800w,/assets/img/2024-09-05-SuGaR/13-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/2024-09-05-SuGaR/13.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <h2 id="code-flow">Code Flow</h2> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-09-05-SuGaR/14-480.webp 480w,/assets/img/2024-09-05-SuGaR/14-800.webp 800w,/assets/img/2024-09-05-SuGaR/14-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/2024-09-05-SuGaR/14.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> 출처 : NeRF and 3DGS Study </div> <h2 id="question">Question</h2> <ul> <li>Q1 : well-distributed 가정을 따르는 approx. ideal density function을 직접 구해서 이를 density function과 비교하는데, GT 역할을 하는 approx. ideal density function이, 변하는 learnable Gaussian으로 구한 것이어도 학습이 안정적임?</li> <li>A1 : TBD</li> </ul> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/"></d-bibliography> <div id="disqus_thread" style="max-width: 800px; margin: 0 auto;"> <script type="text/javascript">var disqus_shortname="semyeong-yu",disqus_identifier="/blog/2024/SuGaR",disqus_title="SuGaR";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}();</script> <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by Disqus.</a> </noscript> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2024 Semyeong Yu. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-5YMLX9VHFX"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-5YMLX9VHFX");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>